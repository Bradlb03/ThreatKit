from flask import (
    Blueprint,
    render_template,
    request,
    redirect,
    url_for,
    flash,
    current_app,
    jsonify,
)
from werkzeug.utils import secure_filename
import os
import joblib
import numpy as np
import pefile
from . import ML_MODEL, SCALER
import pandas as pd

# -----------------------------
# Blueprint + base paths
# -----------------------------
bp = Blueprint("malware", __name__, template_folder="../templates")

BASE_DIR = os.path.dirname(os.path.abspath(__file__))
MODELS_DIR = os.path.join(BASE_DIR, "models")
RULES_DIR = os.path.join(BASE_DIR, "rules")

MODEL_PATH = os.path.join(MODELS_DIR, "baseline.pkl")
SCALER_PATH = os.path.join(MODELS_DIR, "scaler.pkl")
YARA_RULES_PATH = os.path.join(RULES_DIR, "initial_rules.yar")

ALLOWED_EXTENSIONS = {"exe", "dll", "scr", "pdf", "zip", "docx", "xlsx", "txt"}

# -----------------------------
# Load ML model + scaler
# -----------------------------
try:
    MODEL = joblib.load(MODEL_PATH)
    print(f"[ML] Loaded model from {MODEL_PATH}")
except Exception as e:
    print("[ML] ERROR loading model:", e)
    MODEL = None

try:
    SCALER = joblib.load(SCALER_PATH)
    print(f"[ML] Loaded scaler from {SCALER_PATH}")
except Exception as e:
    print("[ML] ERROR loading scaler:", e)
    SCALER = None

# -----------------------------
# Load YARA
# -----------------------------
try:
    import yara  # YARA bindings

    YARA_AVAILABLE = True
    YARA_RULES = yara.compile(filepath=YARA_RULES_PATH)
    print(f"[YARA] Loaded rules from {YARA_RULES_PATH}")
except Exception as e:
    print("[YARA] Disabled â€“ error loading libyara/rules:", e)
    yara = None
    YARA_AVAILABLE = False
    YARA_RULES = None

# -----------------------------
# Helpers
# -----------------------------
def allowed_file(filename: str) -> bool:
    return "." in filename and filename.rsplit(".", 1)[1].lower() in ALLOWED_EXTENSIONS


def compute_byte_entropy(data: bytes, num_bins: int = 256) -> float:
    """Shannon entropy in bits/byte."""
    if not data:
        return 0.0
    arr = np.frombuffer(data, dtype=np.uint8)
    counts = np.bincount(arr, minlength=num_bins)
    probs = counts / float(len(arr))
    probs = probs[probs > 0]
    return float(-np.sum(probs * np.log2(probs)))


def extract_features_from_bytes(data: bytes) -> dict:
    """
    Extract static features for the ML model:
    - byteentropy_true
    - import_count (using pefile for PE binaries)
    """
    entropy = compute_byte_entropy(data)
    import_count = 0

    # Try to parse as PE to count imports
    try:
        pe = pefile.PE(data=data, fast_load=True)
        pe.parse_data_directories(
            directories=[pefile.DIRECTORY_ENTRY["IMAGE_DIRECTORY_ENTRY_IMPORT"]]
        )
        if hasattr(pe, "DIRECTORY_ENTRY_IMPORT"):
            import_count = sum(len(entry.imports) for entry in pe.DIRECTORY_ENTRY_IMPORT)
    except Exception:
        # Not a PE file or parsing failed -> keep import_count = 0
        pass

    return {
        "byteentropy_true": entropy,
        "import_count": import_count,
    }


def run_yara_rules(data: bytes):
    """
    Run YARA rules on raw file bytes.
    Returns: (yara_score: float 0-1, rules_triggered: list[str])
    """
    if not YARA_AVAILABLE or YARA_RULES is None:
        return 0.0, []

    matches = YARA_RULES.match(data=data)
    rule_names = [m.rule for m in matches]

    if not matches:
        score = 0.0
    else:
        # Simple heuristic: one rule = 0.6, more rules push toward 1.0
        base = 0.6
        score = min(1.0, base + 0.1 * (len(matches) - 1))

    return float(score), rule_names


# -----------------------------
# Page routes (HTML)
# -----------------------------
@bp.route("/")
def index():
    return render_template("malware.html")


# -----------------------------
# File upload (UI path)
# -----------------------------
@bp.route("/upload", methods=["POST"])
def upload_file():
    if "file" not in request.files:
        flash("No file part")
        return redirect(url_for("malware.index"))

    file = request.files["file"]

    if file.filename == "":
        flash("No selected file")
        return redirect(url_for("malware.index"))

    if file and allowed_file(file.filename):
        filename = secure_filename(file.filename)
        upload_folder = current_app.config["UPLOAD_FOLDER"]
        os.makedirs(upload_folder, exist_ok=True)
        file.save(os.path.join(upload_folder, filename))
        flash(f"File '{filename}' uploaded successfully.")
        return redirect(url_for("malware.index"))
    else:
        flash("Invalid file type.")
        return redirect(url_for("malware.index"))


# -----------------------------
# Core API: /malware/scan
# -----------------------------
@bp.route("/scan", methods=["POST"])
def scan_file():
    """
    Core malware scan endpoint.
    - Reads uploaded file bytes
    - Extracts static features (entropy, import_count)
    - Scales & runs ML model
    - Runs YARA rules
    - Combines both into a final decision
    """
    file = request.files.get("file")
    if not file or file.filename == "":
        return jsonify({"error": "No file provided"}), 400

    data = file.read()
    if not data:
        return jsonify({"error": "Empty file"}), 400

    # ---------- FEATURE EXTRACTION ----------
    feature_dict = extract_features_from_bytes(data)

    # Keep feature order consistent with training
    feature_order = ["byteentropy_true", "import_count"]

    # Build a one-row DataFrame with named columns
    X = pd.DataFrame(
        [[feature_dict[name] for name in feature_order]],
        columns=feature_order,
    )

    # ---------- SCALE + ML PREDICTION ----------
    try:
        # scaler.transform returns a numpy array; wrap it back in a DataFrame
        X_scaled_array = SCALER.transform(X)
        X_scaled = pd.DataFrame(X_scaled_array, columns=feature_order)
    except Exception as e:
        print("[ML] Scaling error, using raw features:", e)
        X_scaled = X

    try:
        proba = ML_MODEL.predict_proba(X_scaled)[0][1]  # P(malicious)
        ml_score = float(proba)
    except Exception as e:
        print("[ML] Predict error:", e)
        ml_score = 0.0

    # ---------- YARA ----------
    yara_score, rules_triggered = run_yara_rules(data)

    # ---------- COMBINE ----------
    # We slightly favor ML but give YARA a strong voice
    w_ml = 0.6
    w_yara = 0.4
    combined_score = w_ml * ml_score + w_yara * yara_score

    # Strong YARA hit overrides
    if rules_triggered and yara_score >= 0.6:
        final_label = "malicious"
    else:
        threshold = 0.4  #tune this (e.g., 0.35 to reduce FNs)
        final_label = "malicious" if combined_score >= threshold else "benign"

    return jsonify({
        "features": feature_dict,
        "ml_score": round(ml_score, 3),
        "yara_score": round(yara_score, 3),
        "score": round(combined_score, 3),  # final combined score
        "prediction": final_label,
        "rules_triggered": rules_triggered,
    })
